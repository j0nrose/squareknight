<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Crawler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            display: flex;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
        }

        .game-canvas {
            flex: 1;
            background: #000;
            border: 2px solid #333;
            position: relative;
            min-height: 400px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-panel {
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            padding: 20px;
            overflow-y: auto;
        }

        .stats {
            margin-bottom: 20px;
        }

        .stat-bar {
            margin: 10px 0;
        }

        .stat-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 1px solid #555;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .health-bar { background: #e74c3c; }
        .mana-bar { background: #3498db; }
        .exp-bar { background: #f39c12; }

        .inventory {
            margin-bottom: 20px;
        }

        .inventory h3 {
            margin-bottom: 10px;
            color: #f39c12;
        }

        .item {
            padding: 5px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .item:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .message-log {
            height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            padding: 10px;
            margin-bottom: 20px;
        }

        .message {
            margin-bottom: 5px;
            font-size: 12px;
            line-height: 1.4;
        }

        .choice-panel {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #f39c12;
            padding: 20px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 400px;
            z-index: 100;
            display: none;
        }

        .choice-text {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .choice-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .choice-btn {
            padding: 10px 20px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            flex: 1;
        }

        .choice-btn:hover {
            background: #555;
            border-color: #f39c12;
        }

        .controls {
            font-size: 12px;
            color: #888;
        }

        .boss-health {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 2px solid #e74c3c;
            display: none;
        }

        .boss-name {
            text-align: center;
            color: #e74c3c;
            font-weight: bold;
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }
            
            .ui-panel {
                width: 100%;
                height: 200px;
                order: 2;
            }
            
            .game-canvas {
                order: 1;
                height: calc(100vh - 200px);
            }
            
            .choice-panel {
                width: 90%;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-canvas">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div class="boss-health" id="bossHealth">
                <div class="boss-name" id="bossName">Boss Name</div>
                <div class="bar">
                    <div class="bar-fill health-bar" id="bossHealthBar" style="width: 100%"></div>
                </div>
            </div>
        </div>
        
        <div class="ui-panel">
            <div class="stats">
                <div class="stat-bar">
                    <span class="stat-label">Health: <span id="healthText">100/100</span></span>
                    <div class="bar">
                        <div class="bar-fill health-bar" id="healthBar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">Mana: <span id="manaText">50/50</span></span>
                    <div class="bar">
                        <div class="bar-fill mana-bar" id="manaBar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span class="stat-label">Level: <span id="levelText">1</span> | XP: <span id="expText">0/100</span></span>
                    <div class="bar">
                        <div class="bar-fill exp-bar" id="expBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            
            <div class="inventory">
                <h3>Inventory</h3>
                <div id="inventoryItems">
                    <div class="item">Sword (+10 Attack)</div>
                    <div class="item">Health Potion x3</div>
                </div>
            </div>
            
            <div class="message-log" id="messageLog">
                <div class="message">Welcome to the dungeon!</div>
                <div class="message">Use WASD or arrow keys to move</div>
                <div class="message">Space to attack, E to interact</div>
            </div>
            
            <div class="controls">
                <p>Controls:</p>
                <p>WASD/Arrows: Move</p>
                <p>Space: Attack</p>
                <p>E: Interact</p>
            </div>
        </div>
    </div>
    
    <div class="choice-panel" id="choicePanel">
        <div class="choice-text" id="choiceText">Choose your path:</div>
        <div class="choice-buttons" id="choiceButtons">
            <button class="choice-btn" onclick="makeChoice('yes')">Yes</button>
            <button class="choice-btn" onclick="makeChoice('no')">No</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            player: {
                x: 50,
                y: 50,
                width: 20,
                height: 20,
                speed: 3,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                level: 1,
                exp: 0,
                expToNext: 100,
                attack: 20,
                color: '#3498db'
            },
            enemies: [],
            bosses: [],
            walls: [],
            items: [],
            keys: {},
            currentBoss: null,
            gameWidth: 800,
            gameHeight: 600,
            currentRoom: 0,
            inventory: ['Sword', 'Health Potion', 'Health Potion', 'Health Potion'],
            messages: []
        };

        // Enemy types
        const enemyTypes = {
            goblin: {
                health: 30,
                attack: 8,
                speed: 1,
                color: '#e74c3c',
                size: 15
            },
            orc: {
                health: 50,
                attack: 12,
                speed: 0.8,
                color: '#8e44ad',
                size: 18
            },
            skeleton: {
                health: 25,
                attack: 10,
                speed: 1.2,
                color: '#ecf0f1',
                size: 16
            }
        };

        // Boss types
        const bossTypes = {
            dragonLord: {
                name: 'Dragon Lord',
                health: 200,
                maxHealth: 200,
                attack: 25,
                speed: 0.5,
                color: '#e74c3c',
                size: 40,
                specialAttack: 'fireBreath'
            },
            shadowKing: {
                name: 'Shadow King',
                health: 150,
                maxHealth: 150,
                attack: 20,
                speed: 1,
                color: '#2c3e50',
                size: 35,
                specialAttack: 'shadowStrike'
            },
            crystalGuardian: {
                name: 'Crystal Guardian',
                health: 300,
                maxHealth: 300,
                attack: 30,
                speed: 0.3,
                color: '#9b59b6',
                size: 45,
                specialAttack: 'crystalShards'
            }
        };

        // Room layouts
        const rooms = [
            {
                walls: [
                    {x: 0, y: 0, width: 800, height: 20},
                    {x: 0, y: 0, width: 20, height: 600},
                    {x: 780, y: 0, width: 20, height: 600},
                    {x: 0, y: 580, width: 800, height: 20}
                ],
                enemies: [
                    {type: 'goblin', x: 200, y: 200},
                    {type: 'goblin', x: 400, y: 300},
                    {type: 'skeleton', x: 600, y: 150}
                ],
                items: [
                    {type: 'health', x: 100, y: 500},
                    {type: 'mana', x: 700, y: 100}
                ],
                exit: {x: 750, y: 290, width: 30, height: 40}
            },
            {
                walls: [
                    {x: 0, y: 0, width: 800, height: 20},
                    {x: 0, y: 0, width: 20, height: 600},
                    {x: 780, y: 0, width: 20, height: 600},
                    {x: 0, y: 580, width: 800, height: 20},
                    {x: 200, y: 200, width: 400, height: 20},
                    {x: 200, y: 380, width: 400, height: 20}
                ],
                enemies: [
                    {type: 'orc', x: 300, y: 100},
                    {type: 'orc', x: 500, y: 450},
                    {type: 'skeleton', x: 400, y: 290}
                ],
                boss: {type: 'shadowKing', x: 400, y: 500},
                items: [
                    {type: 'health', x: 50, y: 300},
                    {type: 'upgrade', x: 750, y: 300}
                ],
                exit: {x: 750, y: 290, width: 30, height: 40}
            },
            {
                walls: [
                    {x: 0, y: 0, width: 800, height: 20},
                    {x: 0, y: 0, width: 20, height: 600},
                    {x: 780, y: 0, width: 20, height: 600},
                    {x: 0, y: 580, width: 800, height: 20}
                ],
                enemies: [
                    {type: 'orc', x: 150, y: 150},
                    {type: 'orc', x: 650, y: 150},
                    {type: 'skeleton', x: 200, y: 400},
                    {type: 'skeleton', x: 600, y: 400}
                ],
                boss: {type: 'dragonLord', x: 400, y: 300},
                items: [
                    {type: 'health', x: 50, y: 50},
                    {type: 'mana', x: 750, y: 50}
                ],
                exit: {x: 750, y: 290, width: 30, height: 40}
            }
        ];

        // Initialize game
        function initGame() {
            loadRoom(0);
            gameLoop();
        }

        function loadRoom(roomIndex) {
            if (roomIndex >= rooms.length) {
                showChoice("You've conquered the entire dungeon! Do you want to play again?", ['Yes', 'No'], ['restart', 'end']);
                return;
            }

            gameState.currentRoom = roomIndex;
            const room = rooms[roomIndex];
            
            // Reset player position
            gameState.player.x = 50;
            gameState.player.y = 50;
            
            // Load walls
            gameState.walls = [...room.walls];
            
            // Load enemies
            gameState.enemies = [];
            if (room.enemies) {
                room.enemies.forEach(enemyData => {
                    const enemy = createEnemy(enemyData.type, enemyData.x, enemyData.y);
                    gameState.enemies.push(enemy);
                });
            }
            
            // Load boss
            gameState.bosses = [];
            if (room.boss) {
                const boss = createBoss(room.boss.type, room.boss.x, room.boss.y);
                gameState.bosses.push(boss);
            }
            
            // Load items
            gameState.items = [];
            if (room.items) {
                room.items.forEach(itemData => {
                    gameState.items.push({
                        type: itemData.type,
                        x: itemData.x,
                        y: itemData.y,
                        width: 15,
                        height: 15
                    });
                });
            }
            
            addMessage(`Entered room ${roomIndex + 1}`);
        }

        function createEnemy(type, x, y) {
            const enemyData = enemyTypes[type];
            return {
                type: type,
                x: x,
                y: y,
                width: enemyData.size,
                height: enemyData.size,
                health: enemyData.health,
                maxHealth: enemyData.health,
                attack: enemyData.attack,
                speed: enemyData.speed,
                color: enemyData.color,
                lastAttack: 0,
                ai: 'chase'
            };
        }

        function createBoss(type, x, y) {
            const bossData = bossTypes[type];
            return {
                type: type,
                x: x,
                y: y,
                width: bossData.size,
                height: bossData.size,
                health: bossData.health,
                maxHealth: bossData.maxHealth,
                attack: bossData.attack,
                speed: bossData.speed,
                color: bossData.color,
                name: bossData.name,
                specialAttack: bossData.specialAttack,
                lastAttack: 0,
                lastSpecial: 0,
                ai: 'boss'
            };
        }

        // Input handling
        window.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;
            gameState.keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
            gameState.keys[e.code] = false;
        });

        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            updatePlayer();
            updateEnemies();
            updateBosses();
            checkCollisions();
            checkInteractions();
        }

        function updatePlayer() {
            const player = gameState.player;
            let dx = 0, dy = 0;
            
            if (gameState.keys['w'] || gameState.keys['ArrowUp']) dy = -player.speed;
            if (gameState.keys['s'] || gameState.keys['ArrowDown']) dy = player.speed;
            if (gameState.keys['a'] || gameState.keys['ArrowLeft']) dx = -player.speed;
            if (gameState.keys['d'] || gameState.keys['ArrowRight']) dx = player.speed;
            
            // Check wall collisions
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            if (!checkWallCollision(newX, player.y, player.width, player.height)) {
                player.x = newX;
            }
            if (!checkWallCollision(player.x, newY, player.width, player.height)) {
                player.y = newY;
            }
            
            // Attack
            if (gameState.keys[' '] || gameState.keys['Space']) {
                attack();
            }
        }

        function updateEnemies() {
            gameState.enemies.forEach((enemy, index) => {
                if (enemy.health <= 0) {
                    gameState.enemies.splice(index, 1);
                    gainExp(20);
                    addMessage(`Defeated ${enemy.type}!`);
                    return;
                }
                
                // Simple AI - move towards player
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const moveX = (dx / distance) * enemy.speed;
                    const moveY = (dy / distance) * enemy.speed;
                    
                    if (!checkWallCollision(enemy.x + moveX, enemy.y, enemy.width, enemy.height)) {
                        enemy.x += moveX;
                    }
                    if (!checkWallCollision(enemy.x, enemy.y + moveY, enemy.width, enemy.height)) {
                        enemy.y += moveY;
                    }
                }
                
                // Attack player if close
                if (distance < 30 && Date.now() - enemy.lastAttack > 1000) {
                    damagePlayer(enemy.attack);
                    enemy.lastAttack = Date.now();
                }
            });
        }

        function updateBosses() {
            gameState.bosses.forEach((boss, index) => {
                if (boss.health <= 0) {
                    gameState.bosses.splice(index, 1);
                    gameState.currentBoss = null;
                    document.getElementById('bossHealth').style.display = 'none';
                    gainExp(100);
                    addMessage(`Defeated ${boss.name}!`);
                    
                    // Boss death choice
                    setTimeout(() => {
                        showChoice(`The ${boss.name} lies defeated. A mysterious portal appears. Do you enter it?`, 
                                 ['Enter Portal', 'Stay and Rest'], 
                                 ['nextRoom', 'rest']);
                    }, 1000);
                    return;
                }
                
                // Show boss health bar
                if (!gameState.currentBoss) {
                    gameState.currentBoss = boss;
                    document.getElementById('bossHealth').style.display = 'block';
                    document.getElementById('bossName').textContent = boss.name;
                }
                
                // Update boss health bar
                const healthPercent = (boss.health / boss.maxHealth) * 100;
                document.getElementById('bossHealthBar').style.width = healthPercent + '%';
                
                // Boss AI
                const dx = gameState.player.x - boss.x;
                const dy = gameState.player.y - boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    const moveX = (dx / distance) * boss.speed;
                    const moveY = (dy / distance) * boss.speed;
                    
                    if (!checkWallCollision(boss.x + moveX, boss.y, boss.width, boss.height)) {
                        boss.x += moveX;
                    }
                    if (!checkWallCollision(boss.x, boss.y + moveY, boss.width, boss.height)) {
                        boss.y += moveY;
                    }
                }
                
                // Regular attack
                if (distance < 50 && Date.now() - boss.lastAttack > 1500) {
                    damagePlayer(boss.attack);
                    boss.lastAttack = Date.now();
                    addMessage(`${boss.name} attacks!`);
                }
                
                // Special attack
                if (distance < 100 && Date.now() - boss.lastSpecial > 5000) {
                    useSpecialAttack(boss);
                    boss.lastSpecial = Date.now();
                }
            });
        }

        function useSpecialAttack(boss) {
            switch(boss.specialAttack) {
                case 'fireBreath':
                    damagePlayer(boss.attack * 1.5);
                    addMessage(`${boss.name} breathes fire!`);
                    break;
                case 'shadowStrike':
                    damagePlayer(boss.attack * 1.2);
                    addMessage(`${boss.name} strikes from the shadows!`);
                    break;
                case 'crystalShards':
                    damagePlayer(boss.attack * 1.8);
                    addMessage(`${boss.name} launches crystal shards!`);
                    break;
            }
        }

        function checkWallCollision(x, y, width, height) {
            return gameState.walls.some(wall => 
                x < wall.x + wall.width &&
                x + width > wall.x &&
                y < wall.y + wall.height &&
                y + height > wall.y
            );
        }

        function checkCollisions() {
            // Check item collection
            gameState.items.forEach((item, index) => {
                if (gameState.player.x < item.x + item.width &&
                    gameState.player.x + gameState.player.width > item.x &&
                    gameState.player.y < item.y + item.height &&
                    gameState.player.y + gameState.player.height > item.y) {
                    
                    collectItem(item);
                    gameState.items.splice(index, 1);
                }
            });
            
            // Check exit
            const room = rooms[gameState.currentRoom];
            if (room.exit && gameState.enemies.length === 0 && gameState.bosses.length === 0) {
                const exit = room.exit;
                if (gameState.player.x < exit.x + exit.width &&
                    gameState.player.x + gameState.player.width > exit.x &&
                    gameState.player.y < exit.y + exit.height &&
                    gameState.player.y + gameState.player.height > exit.y) {
                    
                    loadRoom(gameState.currentRoom + 1);
                }
            }
        }

        function checkInteractions() {
            if (gameState.keys['e']) {
                // Check for nearby interactables
                const nearbyItems = gameState.items.filter(item => {
                    const dx = gameState.player.x - item.x;
                    const dy = gameState.player.y - item.y;
                    return Math.sqrt(dx * dx + dy * dy) < 50;
                });
                
                if (nearbyItems.length > 0) {
                    showChoice("You found a mysterious chest. Do you open it?", 
                             ['Open', 'Leave'], 
                             ['openChest', 'leave']);
                }
            }
        }

        function attack() {
            // Attack enemies
            gameState.enemies.forEach(enemy => {
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 40) {
                    enemy.health -= gameState.player.attack;
                    addMessage(`Hit ${enemy.type} for ${gameState.player.attack} damage!`);
                }
            });
            
            // Attack bosses
            gameState.bosses.forEach(boss => {
                const dx = gameState.player.x - boss.x;
                const dy = gameState.player.y - boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 60) {
                    boss.health -= gameState.player.attack;
                    addMessage(`Hit ${boss.name} for ${gameState.player.attack} damage!`);
                }
            });
        }

        function collectItem(item) {
            switch(item.type) {
                case 'health':
                    gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 30);
                    addMessage('Found health potion!');
                    break;
                case 'mana':
                    gameState.player.mana = Math.min(gameState.player.maxMana, gameState.player.mana + 20);
                    addMessage('Found mana crystal!');
                    break;
                case 'upgrade':
                    gameState.player.attack += 5;
                    addMessage('Found weapon upgrade!');
                    break;
            }
            updateUI();
        }

        function damagePlayer(damage) {
            gameState.player.health -= damage;
            addMessage(`Took ${damage} damage!`);
            
            if (gameState.player.health <= 0) {
                showChoice("You have died! Do you want to try again?", 
                         ['Restart', 'Give Up'], 
                         ['restart', 'end']);
            }
            updateUI();
        }

        function gainExp(amount) {
            gameState.player.exp += amount;
            if (gameState.player.exp >= gameState.player.expToNext) {
                levelUp();
            }
            updateUI();
        }

        function levelUp() {
            gameState.player.level++;
            gameState.player.exp = 0;
            gameState.player.expToNext += 50;
            gameState.player.maxHealth += 20;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.maxMana += 10;
            gameState.player.mana = gameState.player.maxMana;
            gameState.player.attack += 3;
            addMessage(`Level up! Now level ${gameState.player.level}`);
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw walls
            ctx.fillStyle = '#666';
            gameState.walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });
            
            // Draw items
            gameState.items.forEach(item => {
                switch(item.type) {
                    case 'health':
                        ctx.fillStyle = '#e74c3c';
                        break;
                    case 'mana':
                        ctx.fillStyle = '#3498db';
                        break;
                    case 'upgrade':
                        ctx.fillStyle = '#f39c12';
                        break;
                }
                ctx.fillRect(item.x, item.y, item.width, item.height);
            });
            
            // Draw enemies
            gameState.enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // Health bar
                const healthPercent = enemy.health / enemy.maxHealth;
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * healthPercent, 5);
                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x + (enemy.width * healthPercent), enemy.y - 10, enemy.width * (1 - healthPercent), 5);
            });
            
            // Draw bosses
            gameState.bosses.forEach(boss => {
                ctx.fillStyle = boss.color;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                
                // Boss glow effect
                ctx.shadowColor = boss.color;
                ctx.shadowBlur = 10;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                ctx.shadowBlur = 0;
            });
            
            // Draw player
            ctx.fillStyle = gameState.player.color;
            ctx.fillRect(gameState.player.x, gameState.player.y, gameState.player.width, gameState.player.height);
            
            // Draw exit if room is cleared
            const room = rooms[gameState.currentRoom];
            if (room.exit && gameState.enemies.length === 0 && gameState.bosses.length === 0) {
                ctx.fillStyle = '#2ecc71';
                ctx.fillRect(room.exit.x, room.exit.y, room.exit.width, room.exit.height);
                
                // Exit glow
                ctx.shadowColor = '#2ecc71';
                ctx.shadowBlur = 20;
                ctx.fillRect(room.exit.x, room.exit.y, room.exit.width, room.exit.height);
                ctx.shadowBlur = 0;
            }
        }

        function updateUI() {
            const player = gameState.player;
            
            // Update health bar
            const healthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('healthBar').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = `${player.health}/${player.maxHealth}`;
            
            // Update mana bar
            const manaPercent = (player.mana / player.maxMana) * 100;
            document.getElementById('manaBar').style.width = manaPercent + '%';
            document.getElementById('manaText').textContent = `${player.mana}/${player.maxMana}`;
            
            // Update exp bar
            const expPercent = (player.exp / player.expToNext) * 100;
            document.getElementById('expBar').style.width = expPercent + '%';
            document.getElementById('expText').textContent = `${player.exp}/${player.expToNext}`;
            document.getElementById('levelText').textContent = player.level;
            
            // Update inventory
            const inventoryDiv = document.getElementById('inventoryItems');
            inventoryDiv.innerHTML = '';
            gameState.inventory.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'item';
                itemDiv.textContent = item;
                itemDiv.onclick = () => useItem(item);
                inventoryDiv.appendChild(itemDiv);
            });
        }

        function useItem(item) {
            const index = gameState.inventory.indexOf(item);
            if (index === -1) return;
            
            switch(item) {
                case 'Health Potion':
                    if (gameState.player.health < gameState.player.maxHealth) {
                        gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 50);
                        gameState.inventory.splice(index, 1);
                        addMessage('Used health potion!');
                        updateUI();
                    }
                    break;
                case 'Mana Potion':
                    if (gameState.player.mana < gameState.player.maxMana) {
                        gameState.player.mana = Math.min(gameState.player.maxMana, gameState.player.mana + 30);
                        gameState.inventory.splice(index, 1);
                        addMessage('Used mana potion!');
                        updateUI();
                    }
                    break;
            }
        }

        function addMessage(text) {
            const messageLog = document.getElementById('messageLog');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.textContent = text;
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;
            
            // Keep only last 20 messages
            while (messageLog.children.length > 20) {
                messageLog.removeChild(messageLog.firstChild);
            }
        }

        function showChoice(text, choices, actions) {
            const choicePanel = document.getElementById('choicePanel');
            const choiceText = document.getElementById('choiceText');
            const choiceButtons = document.getElementById('choiceButtons');
            
            choiceText.textContent = text;
            choiceButtons.innerHTML = '';
            
            choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice;
                button.onclick = () => makeChoice(actions[index]);
                choiceButtons.appendChild(button);
            });
            
            choicePanel.style.display = 'block';
        }

        function makeChoice(action) {
            const choicePanel = document.getElementById('choicePanel');
            choicePanel.style.display = 'none';
            
            switch(action) {
                case 'yes':
                case 'nextRoom':
                case 'enter':
                    loadRoom(gameState.currentRoom + 1);
                    break;
                case 'no':
                case 'leave':
                    addMessage('You decide to stay where you are.');
                    break;
                case 'rest':
                    gameState.player.health = gameState.player.maxHealth;
                    gameState.player.mana = gameState.player.maxMana;
                    addMessage('You rest and recover your strength.');
                    updateUI();
                    break;
                case 'openChest':
                    const rewards = ['Health Potion', 'Mana Potion', 'Magic Sword'];
                    const reward = rewards[Math.floor(Math.random() * rewards.length)];
                    gameState.inventory.push(reward);
                    addMessage(`Found ${reward} in the chest!`);
                    updateUI();
                    break;
                case 'restart':
                    location.reload();
                    break;
                case 'end':
                    addMessage('Thanks for playing!');
                    break;
            }
        }

        // Random events
        function triggerRandomEvent() {
            const events = [
                {
                    text: "You find a mysterious potion. Do you drink it?",
                    choices: ["Drink", "Leave"],
                    actions: ["drinkPotion", "leave"]
                },
                {
                    text: "A wounded traveler asks for help. Do you assist them?",
                    choices: ["Help", "Ignore"],
                    actions: ["help", "ignore"]
                },
                {
                    text: "You hear strange noises ahead. Do you investigate?",
                    choices: ["Investigate", "Go Back"],
                    actions: ["investigate", "goBack"]
                }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            showChoice(event.text, event.choices, event.actions);
        }

        // Enhanced choice handling
        function makeChoice(action) {
            const choicePanel = document.getElementById('choicePanel');
            choicePanel.style.display = 'none';
            
            switch(action) {
                case 'yes':
                case 'nextRoom':
                case 'enter':
                    loadRoom(gameState.currentRoom + 1);
                    break;
                case 'no':
                case 'leave':
                    addMessage('You decide to stay where you are.');
                    break;
                case 'rest':
                    gameState.player.health = gameState.player.maxHealth;
                    gameState.player.mana = gameState.player.maxMana;
                    addMessage('You rest and recover your strength.');
                    updateUI();
                    break;
                case 'openChest':
                    const rewards = ['Health Potion', 'Mana Potion', 'Magic Sword'];
                    const reward = rewards[Math.floor(Math.random() * rewards.length)];
                    gameState.inventory.push(reward);
                    addMessage(`Found ${reward} in the chest!`);
                    updateUI();
                    break;
                case 'drinkPotion':
                    if (Math.random() > 0.5) {
                        gameState.player.maxHealth += 20;
                        gameState.player.health += 20;
                        addMessage('The potion increases your maximum health!');
                    } else {
                        gameState.player.health = Math.max(1, gameState.player.health - 10);
                        addMessage('The potion was poison! You lose health.');
                    }
                    updateUI();
                    break;
                case 'help':
                    gameState.player.exp += 30;
                    addMessage('The traveler rewards you with experience!');
                    gainExp(30);
                    break;
                case 'ignore':
                    addMessage('You ignore the traveler and continue on.');
                    break;
                case 'investigate':
                    if (Math.random() > 0.6) {
                        gameState.inventory.push('Mysterious Artifact');
                        addMessage('You found a mysterious artifact!');
                        updateUI();
                    } else {
                        const enemy = createEnemy('skeleton', gameState.player.x + 50, gameState.player.y + 50);
                        gameState.enemies.push(enemy);
                        addMessage('You were ambushed by a skeleton!');
                    }
                    break;
                case 'goBack':
                    addMessage('You decide to turn back.');
                    break;
                case 'restart':
                    location.reload();
                    break;
                case 'end':
                    addMessage('Thanks for playing!');
                    break;
            }
        }

        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            const threshold = 30;
            
            if (Math.abs(deltaX) > threshold || Math.abs(deltaY) > threshold) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Horizontal swipe
                    if (deltaX > 0) {
                        gameState.keys['d'] = true;
                        setTimeout(() => gameState.keys['d'] = false, 100);
                    } else {
                        gameState.keys['a'] = true;
                        setTimeout(() => gameState.keys['a'] = false, 100);
                    }
                } else {
                    // Vertical swipe
                    if (deltaY > 0) {
                        gameState.keys['s'] = true;
                        setTimeout(() => gameState.keys['s'] = false, 100);
                    } else {
                        gameState.keys['w'] = true;
                        setTimeout(() => gameState.keys['w'] = false, 100);
                    }
                }
            } else {
                // Tap to attack
                attack();
            }
        });

        // Resize handling
        function resizeCanvas() {
            const container = document.querySelector('.game-canvas');
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Update game dimensions
            gameState.gameWidth = canvas.width;
            gameState.gameHeight = canvas.height;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Random events trigger
        setInterval(() => {
            if (Math.random() < 0.1 && gameState.enemies.length === 0 && gameState.bosses.length === 0) {
                triggerRandomEvent();
            }
        }, 10000);

        // Initialize and start game
        initGame();
        updateUI();
    </script>
</body>
</html>